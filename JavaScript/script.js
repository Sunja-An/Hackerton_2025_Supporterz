// -----------------------------------------------------------
// script.js
//
// このファイルは、ホームページ上でPDFファイルのドラッグ＆ドロップ、
// ファイル選択、及びリセットボタンが押されたときの動作を管理するためのものです。
// -----------------------------------------------------------


// =====================================
// 1. HTMLの要素をJavaScriptで使えるように変数に保存する
// =====================================

// 「pdf-dropzone」は、ユーザーがPDFファイルをドラッグ＆ドロップできるエリアです。
const pdfDropzone = document.getElementById('pdf-dropzone');

// 「pdfInput」は、実際のファイル入力（隠れている）を持つ要素です。
// これを使ってユーザーにファイル選択ダイアログを表示させます。
const pdfInput = document.getElementById('pdfInput');


// =====================================
// 2. PDF入力エリアの動作を設定する
// =====================================

// ----- 2-1. ドロップゾーンをクリックしたときの処理 -----
//
// ユーザーが「pdf-dropzone」をクリックすると、隠れているファイル入力「pdfInput」
// のクリックイベントを強制的に発生させ、ファイル選択ダイアログを表示させます。
pdfDropzone.addEventListener('click', () => {
  pdfInput.click();
});


// ----- 2-2. ドラッグしているときの処理（ドラッグオーバー） -----
//
// ユーザーがファイルをドラッグして「pdf-dropzone」の上に置いたときに発生します。
// このイベント内では、以下の2点を行います：
// 1. ブラウザのデフォルトの動作をキャンセル（e.preventDefault()）。
// 2. 視覚的なフィードバックとして、エリアのスタイルを変更（クラス「dragover」を追加）。
pdfDropzone.addEventListener('dragover', (e) => {
  e.preventDefault(); // ブラウザがファイルを自動的に開かないようにするため
  pdfDropzone.classList.add('dragover'); // CSSで指定した見た目に変更
});


// ----- 2-3. ドラッグがエリアから離れたときの処理（ドラッグリーブ） -----
//
// ユーザーがファイルをエリアからドラッグして離したときに発生します。
// このときは、先ほど追加した視覚的フィードバック（クラス「dragover」）を削除します。
pdfDropzone.addEventListener('dragleave', (e) => {
  e.preventDefault(); // 念のためブラウザの動作をキャンセル
  pdfDropzone.classList.remove('dragover'); // 元のスタイルに戻す
});


// ----- 2-4. ファイルがエリアにドロップされたときの処理 -----
//
// ユーザーが実際にファイルを「pdf-dropzone」にドロップするとこのイベントが発生します。
// この処理では、以下の流れで動作します：
//
// 1. デフォルトの動作（例: ブラウザがファイルを新しいタブで開く）をキャンセル。
// 2. ドラッグ中の視覚的フィードバックを解除。
// 3. ドロップされたファイルのリストから最初のファイルを取得。
// 4. そのファイルがPDFファイルかどうかをチェック。
// 5. PDFの場合は、ドロップゾーン内にファイル名を表示し、
//    必要に応じてファイルデータを後の処理用に変数へ保存することができます。
// 6. PDFでない場合は、エラーメッセージを表示します。
pdfDropzone.addEventListener('drop', (e) => {
  e.preventDefault(); // ブラウザのデフォルト動作を防ぐ
  pdfDropzone.classList.remove('dragover'); // ドラッグ中のスタイルを解除

  // ドロップされたファイルの情報が入ったオブジェクトを取得
  const files = e.dataTransfer.files;
  
  // ファイルが1つ以上ドロップされた場合のみ処理を実施
  if (files.length > 0) {
    // ここでは一番最初のファイルのみを使用します
    const file = files[0];
    
    // ファイルのMIMEタイプが「application/pdf」か確認
    if (file.type === "application/pdf") {
      // PDFファイルである場合、エリア内にファイル名を表示
      pdfDropzone.textContent = file.name;
      
      // ここで必要なら、ファイルの内容を変数に保存したり、
      // サーバーに送信するための処理を追加することが可能です。
    } else {
      // PDF以外のファイルの場合、ユーザーに警告を表示
      alert("PDFファイルをドラッグ＆ドロップしてください。");
    }
  }
});


// =====================================
// 3. ファイル選択ダイアログでの動作を設定する
// =====================================

// pdfInputでファイルが選択されたときに発生するイベントです。
pdfInput.addEventListener('change', (e) => {
  // ユーザーが選んだ最初のファイルを取得します。
  const file = e.target.files[0];
  
  // ファイルが存在し、かつそのタイプがPDFか確認
  if (file && file.type === "application/pdf") {
    // PDFの場合、ドロップゾーンにファイル名を表示します。
    pdfDropzone.textContent = file.name;
  } else {
    // PDFでない場合、エラーメッセージを表示し、ファイル選択をリセットします。
    alert("PDFファイルを選択してください。");
    pdfInput.value = ""; // 入力値を空にする
  }
});


// =====================================
// 4. リセットボタンの動作を設定する
// =====================================

// HTML内にある「リセット」ボタンの要素を取得して変数に保存します。
const resetButton = document.getElementById('resetButton');

// リセットボタンがクリックされたときに実行される処理です。
resetButton.addEventListener('click', () => {
  // ① PDF入力エリアの表示を初期状態に戻す
  pdfDropzone.textContent = "ここにPDFをドラッグ＆ドロップ、またはクリックして選択";
  
  // ② 隠れているファイル入力の値を空にして、前に選択されたファイル情報を消去する
  pdfInput.value = "";
  
  // ③ 時間割テーブル内のすべてのセル（<td>要素）を取得し、
  //     その内容（テキスト）を空文字にしてリセットする
  const cells = document.querySelectorAll('#scheduleTable td');
  cells.forEach(cell => {
    cell.textContent = ""; // 各セルの内容を空にする
  });
});


// =====================================
// 5. 補足説明
// =====================================
//
// 「PDF読み取り開始」ボタンは、HTML内でdata-action属性が設定されています。
// この属性は、後でバックエンド（サーバー側）で処理を開始するときに
// このボタンがどの動作を担当するかを識別しやすくするためのものです。
// 今回のコードでは、まだそのボタンに対して特定の処理は記述していませんが、
// 必要になった際には同様に「addEventListener」を使って処理を追加できます。
